<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Room - Face Tracking</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #video {
            position: absolute; top: 10px; right: 10px;
            width: 160px; height: 120px;
            border: 2px solid rgba(0,255,255,0.5); border-radius: 8px;
            z-index: 100; transform: scaleX(-1); opacity: 0.8;
            filter: grayscale(100%);
        }
        #status {
            position: absolute; top: 10px; left: 10px;
            color: #0ff; font-size: 11px; z-index: 100;
            text-shadow: 0 0 10px #0ff; line-height: 1.6; opacity: 0.8;
        }
        #controls {
            position: absolute; top: 80px; left: 10px; z-index: 100;
            background: rgba(0,20,30,0.85); padding: 15px; border-radius: 8px;
            border: 1px solid rgba(0,255,255,0.4); color: #fff; font-size: 12px;
        }
        #controls label { display: block; margin-bottom: 5px; color: #0ff; }
        #controls select, #controls input[type="range"] {
            width: 150px; margin-bottom: 12px;
            background: rgba(0,40,60,0.8); border: 1px solid #0ff;
            color: #fff; padding: 5px; border-radius: 4px;
        }
        #controls input[type="range"] {
            -webkit-appearance: none; height: 6px; padding: 0;
            background: rgba(0,100,130,0.5);
        }
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            background: #0ff; border-radius: 50%; cursor: pointer;
        }
        .size-display { color: #0ff; font-weight: bold; }
        .toggle-container {
            display: flex; align-items: center; gap: 10px; margin-bottom: 12px;
        }
        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            background: rgba(0,40,60,0.8); border: 1px solid #0ff;
            border-radius: 12px; cursor: pointer; transition: background 0.3s;
        }
        .toggle-switch.active {
            background: rgba(0,180,180,0.6);
        }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 18px; height: 18px; background: #0ff;
            border-radius: 50%; transition: transform 0.3s;
        }
        .toggle-switch.active::after {
            transform: translateX(20px);
        }
        .toggle-label { color: #0ff; font-size: 12px; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff; font-size: 18px; z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Initializing...</div>
        <video id="video" autoplay playsinline></video>
        <div id="status">
            <div>Status: <span id="trackingStatus">Starting...</span></div>
            <div>Eye X: <span id="faceX">0</span></div>
            <div>Eye Y: <span id="faceY">0</span></div>
        </div>
        <div id="controls">
            <label>Model</label>
            <select id="modelSelect">
                <option value="cat">Cat</option>
                <option value="cube">Cube</option>
            </select>
            <label>Size: <span id="sizeValue" class="size-display">7.0</span></label>
            <input type="range" id="sizeSlider" min="1" max="15" step="0.5" value="7">
            <div class="toggle-container">
                <div id="lookAtFaceToggle" class="toggle-switch"></div>
                <span class="toggle-label">Look at Face</span>
            </div>
        </div>
    </div>

    <!-- MediaPipe first -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    
    <!-- Three.js ES Module -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        // =====================
        // Configuration
        // =====================
        const CONFIG = {
            modelPath: 'cute_cat.glb',
            modelScale: 7.0,
            modelRotationY: -Math.PI / 2, // 豁｣髱｢繧貞髄縺九○繧・            
            modelPositionZ: -2, // 謇句燕縺ｫ驟咲ｽｮ
            modelPositionY: -1, // 蝨ｰ髱｢縺ｫ險ｭ鄂ｮ・磯Κ螻九・鬮倥＆9縺ｮ蜊雁・・・            
            roomWidth: 16,
            roomHeight: 9,
            roomDepth: 12,
            parallaxStrength: 12,
            smoothing: 0.08
        };

        // =====================
        // Globals
        // =====================
        let scene, camera, renderer, model;
        let faceDetection, videoElement;
        let eyePosition = { x: 0, y: 0 };
        let targetEyePosition = { x: 0, y: 0 };
        let screenWidth, screenHeight, aspectRatio;
        let lookAtFaceEnabled = false;

        // =====================
        // Initialize
        // =====================
        async function init() {
            updateScreenSize();
            initThreeJS();
            initControls();
            
            // Wait for MediaPipe to be ready
            await waitForMediaPipe();
            await initMediaPipe();
            
            animate();
            window.addEventListener('resize', onWindowResize);
        }
        
        function initControls() {
            // Model select
            document.getElementById('modelSelect').addEventListener('change', (e) => {
                switchModel(e.target.value);
            });
            
            // Size slider
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                updateModelSize(parseFloat(e.target.value));
            });

            // Look at face toggle
            const lookAtToggle = document.getElementById('lookAtFaceToggle');
            lookAtToggle.addEventListener('click', () => {
                lookAtFaceEnabled = !lookAtFaceEnabled;
                lookAtToggle.classList.toggle('active', lookAtFaceEnabled);
            });
        }

        function waitForMediaPipe() {
            return new Promise((resolve) => {
                const check = () => {
                    if (typeof FaceDetection !== 'undefined') {
                        resolve();
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }

        function updateScreenSize() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            aspectRatio = screenWidth / screenHeight;
        }

        // =====================
        // Three.js Setup
        // =====================
        function initThreeJS() {
            const container = document.getElementById('container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a12);

            camera = new THREE.PerspectiveCamera(50, aspectRatio, 0.1, 1000);
            camera.position.set(0, 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(screenWidth, screenHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.insertBefore(renderer.domElement, container.firstChild);

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 1.5));
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
            mainLight.position.set(5, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
            fillLight.position.set(-5, 5, 5);
            scene.add(fillLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
            backLight.position.set(0, 5, -10);
            scene.add(backLight);
            
            const bottomLight = new THREE.DirectionalLight(0xffffff, 0.8);
            bottomLight.position.set(0, -5, 5);
            scene.add(bottomLight);

            createRoom();
            createModel();
            
            // First render to confirm it works
            renderer.render(scene, camera);
            console.log('Three.js initialized');
        }

        // =====================
        // Room
        // =====================
        function createRoom() {
            const w = CONFIG.roomWidth;
            const h = CONFIG.roomHeight;
            const d = CONFIG.roomDepth;

            // Room walls
            const roomGeo = new THREE.BoxGeometry(w, h, d);
            const roomMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                side: THREE.BackSide,
                metalness: 0.2,
                roughness: 0.8
            });
            const room = new THREE.Mesh(roomGeo, roomMat);
            room.position.z = -d / 2;
            room.receiveShadow = true;
            scene.add(room);
            
            // Floor plane for better shadow
            const floorGeo = new THREE.PlaneGeometry(w, d);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.2,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -h / 2 + 0.02;
            floor.position.z = -d / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grids
            addGrid(w, h, 16, 9, [0, 0, -d + 0.01], [0, 0, 0]); // Back
            addGrid(w, d, 16, 12, [0, -h/2 + 0.01, -d/2], [-Math.PI/2, 0, 0]); // Floor
            addGrid(w, d, 16, 12, [0, h/2 - 0.01, -d/2], [Math.PI/2, 0, 0]); // Ceiling
            addGrid(d, h, 12, 9, [-w/2 + 0.01, 0, -d/2], [0, Math.PI/2, 0]); // Left
            addGrid(d, h, 12, 9, [w/2 - 0.01, 0, -d/2], [0, -Math.PI/2, 0]); // Right

            // Corner edges
            const edgeMat = new LineMaterial({ 
                color: 0x00ffff, 
                linewidth: 4,
                transparent: true,
                opacity: 1.0
            });
            edgeMat.resolution.set(window.innerWidth, window.innerHeight);
            
            const corners = [
                [[-w/2, -h/2, -d], [-w/2, h/2, -d]],
                [[w/2, -h/2, -d], [w/2, h/2, -d]],
                [[-w/2, h/2, -d], [w/2, h/2, -d]],
                [[-w/2, -h/2, -d], [w/2, -h/2, -d]],
                [[-w/2, -h/2, 0], [-w/2, -h/2, -d]],
                [[w/2, -h/2, 0], [w/2, -h/2, -d]],
                [[-w/2, h/2, 0], [-w/2, h/2, -d]],
                [[w/2, h/2, 0], [w/2, h/2, -d]],
            ];
            corners.forEach(([s, e]) => {
                const geo = new LineGeometry();
                geo.setPositions([...s, ...e]);
                scene.add(new Line2(geo, edgeMat));
            });
        }

        function addGrid(w, h, divX, divY, pos, rot) {
            const group = new THREE.Group();
            
            const mat = new LineMaterial({ 
                color: 0x00ffff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.5
            });
            mat.resolution.set(window.innerWidth, window.innerHeight);
            
            for (let i = 0; i <= divX; i++) {
                const x = (i / divX - 0.5) * w;
                const geo = new LineGeometry();
                geo.setPositions([x, -h/2, 0, x, h/2, 0]);
                group.add(new Line2(geo, mat));
            }
            for (let i = 0; i <= divY; i++) {
                const y = (i / divY - 0.5) * h;
                const geo = new LineGeometry();
                geo.setPositions([-w/2, y, 0, w/2, y, 0]);
                group.add(new Line2(geo, mat));
            }
            
            group.position.set(...pos);
            group.rotation.set(...rot);
            scene.add(group);
        }

        // =====================
        // Model
        // =====================
        let currentModelType = 'cat';
        let catModel = null;
        let cubeModel = null;
        
        function createModel() {
            loadCatModel();
            createCubeModel();
        }
        
        function loadCatModel() {
            console.log('Loading cat model:', CONFIG.modelPath);
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelPath, (gltf) => {
                console.log('Cat model loaded successfully');
                catModel = gltf.scene;
                catModel.scale.setScalar(CONFIG.modelScale);
                catModel.position.set(0, CONFIG.modelPositionY, CONFIG.modelPositionZ);
                catModel.rotation.y = CONFIG.modelRotationY;
                
                catModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(catModel);
                model = catModel;
                document.getElementById('loading').style.display = 'none';
            }, 
            (progress) => {
                console.log('Loading progress:', progress);
            },
            (error) => {
                console.error('Cat model load error:', error);
                document.getElementById('modelSelect').value = 'cube';
                switchModel('cube');
            });
        }
        
        function createCubeModel() {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                metalness: 0.7,
                roughness: 0.2,
                emissive: 0x003366,
                emissiveIntensity: 0.3
            });
            cubeModel = new THREE.Mesh(geo, mat);
            cubeModel.position.set(0, CONFIG.modelPositionY, CONFIG.modelPositionZ);
            cubeModel.scale.setScalar(CONFIG.modelScale / 2);
            cubeModel.castShadow = true;
            cubeModel.receiveShadow = true;

            const edges = new THREE.EdgesGeometry(geo);
            cubeModel.add(new THREE.LineSegments(edges, 
                new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })
            ));
            
            cubeModel.visible = false;
            scene.add(cubeModel);
            console.log('Cube model created');
        }
        
        function switchModel(type) {
            currentModelType = type;
            
            if (type === 'cat' && catModel) {
                catModel.visible = true;
                if (cubeModel) cubeModel.visible = false;
                model = catModel;
            } else if (type === 'cube' && cubeModel) {
                cubeModel.visible = true;
                if (catModel) catModel.visible = false;
                model = cubeModel;
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        function updateModelSize(scale) {
            CONFIG.modelScale = scale;
            if (catModel) catModel.scale.setScalar(scale);
            if (cubeModel) cubeModel.scale.setScalar(scale / 2);
            document.getElementById('sizeValue').textContent = scale.toFixed(1);
        }

        function createCube() {
            // Fallback - switch to cube if cat fails
            switchModel('cube');
        }

        // =====================
        // Off-Axis Projection
        // =====================
        function updateCamera() {
            const eyeX = eyePosition.x * CONFIG.parallaxStrength;
            const eyeY = eyePosition.y * CONFIG.parallaxStrength;
            const camZ = 10;

            const fovRad = THREE.MathUtils.degToRad(camera.fov);
            const nearH = 2 * camera.near * Math.tan(fovRad / 2);
            const nearW = nearH * aspectRatio;

            const shiftX = -eyeX * camera.near / camZ;
            const shiftY = -eyeY * camera.near / camZ;

            camera.projectionMatrix.makePerspective(
                -nearW/2 + shiftX, nearW/2 + shiftX,
                nearH/2 + shiftY, -nearH/2 + shiftY,
                camera.near, camera.far
            );
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();

            camera.position.set(eyeX, eyeY, camZ);
        }

        // =====================
        // MediaPipe
        // =====================
        async function initMediaPipe() {
            videoElement = document.getElementById('video');

            faceDetection = new FaceDetection({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
            });

            faceDetection.setOptions({
                model: 'short',
                minDetectionConfidence: 0.3,
                selfieMode: true
            });
            faceDetection.onResults(onFaceResults);

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: 'user' },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                videoElement.srcObject = stream;
                await videoElement.play();

                document.getElementById('trackingStatus').textContent = 'Ready';
                document.getElementById('trackingStatus').style.color = '#0f0';
                console.log('Camera ready');

                detectLoop();
            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('trackingStatus').textContent = 'Camera Error';
            }
        }

        async function detectLoop() {
            if (videoElement.readyState >= 2) {
                await faceDetection.send({ image: videoElement });
            }
            requestAnimationFrame(detectLoop);
        }

        function onFaceResults(results) {
            if (results.detections && results.detections.length > 0) {
                const box = results.detections[0].boundingBox;
                targetEyePosition.x = (box.xCenter - 0.5);
                targetEyePosition.y = -(box.yCenter - 0.5);

                document.getElementById('trackingStatus').textContent = 'Tracking';
                document.getElementById('trackingStatus').style.color = '#0f0';
            } else {
                document.getElementById('trackingStatus').textContent = 'No face';
                document.getElementById('trackingStatus').style.color = '#ff0';
                targetEyePosition.x *= 0.95;
                targetEyePosition.y *= 0.95;
            }
        }

        // =====================
        // Animation
        // =====================
        function animate() {
            requestAnimationFrame(animate);

            eyePosition.x += (targetEyePosition.x - eyePosition.x) * CONFIG.smoothing;
            eyePosition.y += (targetEyePosition.y - eyePosition.y) * CONFIG.smoothing;

            document.getElementById('faceX').textContent = eyePosition.x.toFixed(3);
            document.getElementById('faceY').textContent = eyePosition.y.toFixed(3);

            updateCamera();

            // Look at face mode
            if (model && lookAtFaceEnabled) {
                const targetRotY = CONFIG.modelRotationY + eyePosition.x * 0.9;
                const targetRotX = -eyePosition.y * 0.5;
                model.rotation.y += (targetRotY - model.rotation.y) * 0.1;
                model.rotation.x += (targetRotX - model.rotation.x) * 0.1;
            } else if (model && !lookAtFaceEnabled) {
                model.rotation.y += (CONFIG.modelRotationY - model.rotation.y) * 0.1;
                model.rotation.x += (0 - model.rotation.x) * 0.1;
            }

            renderer.render(scene, camera);
        }

        // =====================
        // Resize
        // =====================
        function onWindowResize() {
            updateScreenSize();
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(screenWidth, screenHeight);
        }

        // =====================
        // Start
        // =====================
        init();
    </script>
</body>
</html>